

#extern void * malloc(int size)
#extern void  free(void * ptr)
#extern void  printf(...)

#extern int socket(int domain, int type, int protocol)
#extern int connect(...)
#extern int write(...)
#extern int read(...)
#extern int fcntl(...)
#extern int poll(...)

#define AF_UNIX 1
#define SOCK_STREAM 1

#define OPEN_FONT_NAME_BYTE_COUNT 5
#define OPEN_FONT_PADDING 3
#define OPEN_FONT_PACKET_U32_COUNT 5
#define X11_OP_REQ_OPEN_FONT 0x2d

#define X11_OP_REQ_CREATE_GC 0x37
#define X11_FLAG_GC_BG 0x00000004
#define X11_FLAG_GC_FG 0x00000008
#define X11_FLAG_GC_FONT 0x00004000
#define X11_FLAG_GC_EXPOSE 0x00010000

#define CREATE_GC_PACKET_FLAG_COUNT 3
#define CREATE_GC_PACKET_U32_COUNT 7
#define MY_COLOR_RGB 0x0000FFFF

#define X11_OP_REQ_MAP_WINDOW 0x08

#define X11_OP_REQ_CREATE_WINDOW 0x01
#define X11_FLAG_WIN_BG_COLOR 0x00000002
#define X11_EVENT_FLAG_KEY_RELEASE 0x0002
#define X11_EVENT_FLAG_EXPOSURE 0x8000
#define X11_FLAG_WIN_EVENT 0x00000800

#define X11_EVENT_EXPOSURE 0xc

#define CREATE_WINDOW_FLAG_COUNT 2
#define CREATE_WINDOW_PACKET_U32_COUNT 10
#define CREATE_WINDOW_BORDER 1
#define CREATE_WINDOW_GROUP 1

#define F_GETFL 3
#define F_SETFL 4
#define O_NONBLOCK 4000

#define POLLIN 0x001
#define POLLPRI 0x002
#define POLLOUT 0x004
#define POLLERR  0x008
#define POLLHUP  0x010
#define POLLNVAL 0x020


struct short{
    byte low;
    byte high;
}

void write_i16_to_bytes(short x, byte * b){
    b[0] = x.low;
    b[1] = x.high;
}

short create_short(int a){
    short out;
    out.low = a & 0xFF;
    out.high = (a >> 8) & 0xFF;

    return out;
}

void place_int(int * numb, byte * b){
    *numb = 0;
    for(int i = 0; i < 4; i++){
        *numb |= b[i] << (i * 8);
    }
}
void place_short(int * numb, byte * b){
    *numb = 0;
    for(int i = 0; i < 2; i++){
        *numb |= b[i] << (i * 8);
    }
}

struct sockaddr_un{
  byte * p;
}

void create_sockaddr_un(sockaddr_un * addr){

  int len = 17;
  string path = "/tmp/.X11-unix/X0";

  addr.p = malloc(110);
  addr.p[0] = AF_UNIX;
  addr.p[1] = 0;

  for(int i = 0; i < len; i++){
    addr.p[i + 2] = path[i];
  }
  for(int i = len + 2; i < 110; i++){
    addr.p[i] = 0;
  }
}

struct x11_connection_req_t{
    byte order;
    byte pad1;
    short major;
    short minor;
    short auto_proto;
    short auth_data;
    short pad2;
}


struct x11_data{
    int id; // 32 bit
    int id_base; // 32 bit
    int id_mask;
    int root_visual_id;
}


void init_data(x11_data * data, byte * res, int server_read){


    // eax global id 0
    // edi id_base 0x1c00000, 29360128
    // edx id_mask 0x1fffff, 2097151

    // id_base is offset 4, int
    place_int(&data.id_base, &res[4]);
    printf("base: %d\n", data.id_base);

    // id_mask is offset 8, int
    place_int(&data.id_mask, &res[8]);
    printf("mask: %d\n", data.id_mask);

    // vendor length is offset 16, short
    int vendor_length;
    place_short(&vendor_length, &res[16]);

    // number of formats, 21 offset, byte, is the size in bytes
    byte formats = res[21] * 8;
    printf("Formats %d\n", formats);


    // (32 + vendor length + 3) & -4 from start O
    int offset = ((35 + vendor_length) & -4) + formats;
    printf("offset: %d\n", offset);

    place_int(&data.id, &res[offset]);
    printf("id: %d\n", data.id);
    place_int(&data.root_visual_id, &res[offset + 32]);

}

int x11_next_id(x11_data * data){

    int out =  data.id_mask & data.id | data.id_base;
    data.id++;
    return out;
}


void write_i64_to_bytes(int a, byte * b){
    for(int i = 0; i < 8; i++){
        b[i] = (a >> (i * 8)) & 0xFF;
    }
}

void write_i32_to_bytes(int a, byte * b){
    for(int i = 0; i < 4; i++){
        b[i] = (a >> (i * 8)) & 0xFF;
    }
}

int open_font(int fd, x11_data * data, int font_id){

    byte * req = malloc(20);

    // first 4 bytes are
    int fst = X11_OP_REQ_OPEN_FONT | (OPEN_FONT_NAME_BYTE_COUNT << 16);
    write_i32_to_bytes(fst, &req[0]);

    // snd ?
    write_i32_to_bytes(font_id, &req[4]);

    // third
    int third = OPEN_FONT_NAME_BYTE_COUNT;
    write_i32_to_bytes(fst, &req[8]);

    string fixed = "fndry";
    for(int i = 0; i < 5; i++){
        req[12] = fixed[i];
    }

    int written = write(fd, req, 20);
    printf("Font req got %d written\n", written);
}



void x11_create_gc(int fd, int font_id, int gc_id, int window_root_id){
    int create_gc_flags = X11_FLAG_GC_BG | X11_FLAG_GC_FG | X11_FLAG_GC_FONT;

    byte * req = malloc(28);

    int fst = X11_OP_REQ_CREATE_GC | (CREATE_GC_PACKET_U32_COUNT << 16);
    write_i32_to_bytes(fst, &req[0]);


    // Graphical context id
    write_i32_to_bytes(gc_id, &req[4]);

    // Window root id
    write_i32_to_bytes(window_root_id, &req[8]);

    write_i32_to_bytes(create_gc_flags, &req[12]);
    write_i32_to_bytes(MY_COLOR_RGB, &req[16]);
    write_i32_to_bytes(0, &req[20]);
    write_i32_to_bytes(font_id, &req[24]);


    int written = write(fd, req, 28);
    if(written != 28){
        printf("Failed to write everything!\n");
        return;
    }
    printf("Created gc context!\n");

}


void x11_create_window(int fd, int new_window_id, int window_root_id, int root_visual_id, short x, short y, short w, short h){

    byte * req = malloc(40);

    int fst = X11_OP_REQ_CREATE_WINDOW | (CREATE_WINDOW_PACKET_U32_COUNT << 16);
    write_i32_to_bytes(fst, req);

    write_i32_to_bytes(new_window_id, &req[4]);
    write_i32_to_bytes(window_root_id, &req[8]);

    write_i16_to_bytes(x, &req[12]);
    printf("%d %d\n", x.low, x.high);
    write_i16_to_bytes(y, &req[14]);
    printf("%d %d\n", req[14], req[15]);
    write_i16_to_bytes(w, &req[16]);
    printf("%d %d\n", req[16], req[17]);
    write_i16_to_bytes(h, &req[18]);
    printf("%d %d\n", req[18], req[19]);


    write_i32_to_bytes(CREATE_WINDOW_GROUP | (CREATE_WINDOW_BORDER << 16), &req[20]);
    write_i32_to_bytes(root_visual_id, &req[24]);
    write_i32_to_bytes(X11_FLAG_WIN_BG_COLOR | X11_FLAG_WIN_EVENT, &req[28]);
    write_i32_to_bytes(0, &req[32]);
    write_i32_to_bytes(X11_EVENT_FLAG_KEY_RELEASE | X11_EVENT_FLAG_EXPOSURE, &req[36]);


    int written = write(fd, req, 40);
    if(written != 40){
        printf("Failed to write create window!\n");
        return;
    }
    printf("Created window!\n");
}


void x11_map_window(int fd, int window_id){

    byte * req = malloc(8);
    write_i32_to_bytes(X11_OP_REQ_MAP_WINDOW | (2 << 16), req);
    write_i32_to_bytes(window_id, &req[4]);

    int written = write(fd, req, 8);
    if(written != 8){
        printf("Failed to map window!\n");
        return;
    }
    printf("Mapped window!\n");

}

int connect_to_fd(int fd, byte * addr){
  int res = connect(fd, addr, 110);
  if(res < 0){
    printf("Failed to connect!\n");
    return 0;
  }
  return 1;
}


int set_fd_non_blocking(int fd){

    int res = fcntl(fd, F_GETFL, 0);
    printf("fcntl F_GETFL got %d\n", res);
    if(res <= 0){
        return 0;
    }

    res |= O_NONBLOCK;
    res = fcntl(fd, F_SETFL, res);
    printf("fcntl F_SETFL got %d\n", res);
    if(res < 0){
        return 0;
    }
    return 1;

}

byte read_reply(int fd){
    byte response[32];
    int res = read(fd, response, 32);
    if(res <= 1){
        printf("Failed to read more then 1?\n");
        return -1;
    }
    return response[0];
}


byte poll_messages(int fd, int window_id, int gc_id){
    byte * req = malloc(32);
    
    write_i32_to_bytes(fd, &req[0]);
    write_i32_to_bytes(POLLIN, &req[4]);
    write_i32_to_bytes(window_id, &req[16]);
    write_i32_to_bytes(gc_id, &req[20]);

    int res = poll(req, 1, -1);
    if(res == 0){
      printf("Failed to poll?\n");
      return -1;
    }
    
    int * pollerr;
    if(POLLERR == pollerr){
      printf("Poll error!\n");
      return -1;
    }
    int * pollhup;
    if(POLLHUP == pollhup){
      printf("Poll hup!\n");
      return -1;
    }

    free(req);
    return read_reply(fd);

}

#define X11_OP_REQ_IMAGE_TEXT8 0x4c
int x11_draw_text(int fd, string s, int s_length, int window_id, int gc_id, short x, short y){

  byte * req = malloc(1024);
  write_i32_to_bytes(window_id, &req[4]);
  write_i32_to_bytes(gc_id, &req[8]);

  write_i16_to_bytes(x, &req[12]);
  write_i16_to_bytes(y, &req[14]);

  int count = (4-(s_length % 4)) % 4;
  int packets = ((count + s_length) >> 2) + 4;

  int fst = (packets << 16) | (s_length << 8) | X11_OP_REQ_IMAGE_TEXT8;
  write_i32_to_bytes(fst, req);

  for(int i = 0; i < s_length; i++){
    req[16 + i] = s[i];
  }

  int write_count = 4 * packets;

  int written = write(fd, req, write_count);
  free(req);

  if(written != write_count){
    printf("Failed to write when writing text! %d out of %d\n", written, write_count);
    return -1;
  }
  return 1;
}

void init_req(x11_connection_req_t * req){
  req.order = 108; // 'l' in ascii
  req.pad1 = 0;
  req.major.low = 11;
  req.major.high = 0;
  req.minor.low = 0;
  req.minor.high = 0;
  req.auto_proto.low = 0;
  req.auto_proto.high = 0;
  req.auth_data.low = 0;
  req.auth_data.high = 0;
  req.pad2.low = 0;
  req.pad2.high = 0;
}


int main(){

  int fd = socket(AF_UNIX, SOCK_STREAM, 0);

  sockaddr_un addr;
  create_sockaddr_un(&addr);

  if(connect_to_fd(fd, addr.p) == 0){
    return 1;
  }

  printf("Connected to %d\n", fd);

  x11_connection_req_t req;
  init_req(&req);

  if(write(fd, &req, 12) != 12){
    printf("failed to write connection req!\n");
    return 1;
  }
  printf("Sent init connection req!\n");

  byte response[8];
  int actually_read = read(fd, response, 8);

  if(actually_read != 8){
    printf("Didn't read the 8 bytes expected but %d!\n", actually_read);
    return 1;
  }

  if(response[0] == 0){
    printf("Failed to read?\n");
    return 1;
  }
  printf("Finished handshake\n");

  int server_res_size = (1<<15) / 4;
  byte * server_res = malloc(server_res_size);

  int server_read = read(fd, server_res, server_res_size);
  if(server_read <= 0){
    printf("Failed to do the big read, read %d\n", server_read);
  }

  x11_data data;
  init_data(&data, server_res, server_read);
  int window_root_id = data.id;
  int gc_id = x11_next_id(&data);
  int font_id = x11_next_id(&data);
  open_font(fd, &data, font_id);
    printf("Opened font!\n");

  x11_create_gc(fd, font_id, gc_id, window_root_id);

  short x = create_short(200);
  short y = create_short(200);

  short w = create_short(400);
  short h = create_short(400);

  int new_window_id = x11_next_id(&data);
  x11_create_window(fd, new_window_id, window_root_id, data.root_visual_id, x, y,w, h);
  x11_map_window(fd, new_window_id);
  printf("new_window %d\ngc_id %d\nwindow_root %d\n", new_window_id, gc_id, window_root_id);

  if(set_fd_non_blocking(fd) == 0){
    return 1;
  }

  byte exposed = 0;
  while(1 == 1){
    byte polled = poll_messages(fd, new_window_id, gc_id);
    if(polled == -1){
        return 0;
    }else{

        if(polled == X11_EVENT_EXPOSURE){
            exposed = 1;
        }
    }
    if(exposed == 1){
        if(x11_draw_text(fd, "hello world", 13, new_window_id, gc_id, create_short(100), create_short(100)) == -1){
            return 1;
        }
    }
  }

  return 0;

}
